> [!TIP]  
> [Ver video](https://youtu.be/B9fdTf19itE)

DNS es un gran ejemplo de un servicio de capa de aplicación que usa UDP para la capa de transporte en lugar de TCP. Esto se puede desglosar en algunas razones simples. Recuerda que la mayor diferencia entre TCP y UDP es que UDP no tiene conexión. Esto significa que no hay configuración ni cierre de una conexión. En general, se necesita transmitir mucho menos tráfico. Una sola solicitud de DNS y su respuesta pueden caber dentro de un solo datagrama UDP, por lo que es un candidato ideal para un protocolo sin conexión.

También vale la pena señalar que DNS puede generar mucho tráfico. Es cierto que las copias en caché de las entradas DNS se guardan en máquinas locales y en servidores de nombres de caché, pero también es cierto que si se necesita procesar una resolución completa, estamos hablando de mucho más tráfico.

Veamos qué aspecto tendría una búsqueda de DNS completa a través de TCP. Primero, el host que se está encargando de la solicitud de resolución de DNS enviaría un paquete SYN al servidor de nombres local en el puerto 53, que es el puerto que escucha DNS. Este servidor de nombres tendría que responder con un paquete SYN ACK, lo que significa que el host original debería responder con un ACK para completar el protocolo de enlace de tres vías. Ahí tenemos tres paquetes.

Ahora que la conexión se estableció, el host original tendría que enviar la solicitud real. "Quisiera saber la dirección IP de food.com, por favor". Cuando reciba esta solicitud, el servidor de nombres tendría que responder con otro ACK. "Tengo tu solicitud de food.com". Hasta aquí, se enviaron cinco paquetes.

En nuestra situación, el primer servidor de almacenamiento de nombres en caché no tiene nada en el caché para food.com. Por lo tanto, debe comunicarse con un servidor de nombres raíz para averiguar quién es responsable del TLD de .com. Esto requeriría un protocolo de enlace de tres vías: la solicitud real, el ACK de la solicitud, la respuesta, y luego el ACK de la respuesta. Por último, la conexión tendría que cerrarse a través de un protocolo de enlace de cuatro vías. Eso son 11 paquetes más, o 16 en total.

Ahora que el servidor de nombres recursivo tiene el servidor de nombres TLD correcto, debe repetir todo el proceso para detectar el servidor de nombres autoritativo adecuado. Eso son 11 paquetes más, lo que nos lleva a 27 hasta ahora. Por último, el servidor de nombres recursivo tendría que repetir todo el proceso una vez más mientras se comunica con el servidor de nombres autoritativo para obtener la IP de food.com. Esto son 11 paquetes más para un total acumulado de 38.

Ahora que el servidor de nombres local finalmente tiene la dirección IP de food.com, puede finalmente responder a la solicitud inicial. Una respuesta al agente de resolución de DNS que originalmente hizo la solicitud, y luego esta computadora envía un ACK de regreso para confirmar que recibió la respuesta. Eso son 2 paquetes más, y llegamos a 40. Por último, la conexión TCP tendría que cerrarse a través de un protocolo de enlace de cuatro vías. Esto nos lleva a un total de 44 paquetes como mínimo para que una solicitud de DNS completamente recursiva se complete a través de TCP.

44 paquetes no es realmente un gran número en cuanto a la rapidez con la que operan las redes modernas. Pero se acumulan rápido, como puedes ver. Recuerda que el tráfico de DNS es solo un precursor del tráfico real. Una computadora casi siempre realiza una búsqueda de DNS porque necesita saber la IP del nombre de dominio para enviar datos adicionales, no solo porque sea curiosa.

Ahora, vamos a ver cómo sería esto con UDP. Alerta de spoiler: no ocupa tantos paquetes.

La computadora original envía un paquete UDP a su servidor de nombres local en el puerto 53 solicitando la IP para food.com, eso es un paquete. El servidor de nombres local actúa como servidor recursivo y envía un paquete UDP al servidor raíz que envía una respuesta que contiene el servidor de nombres TLD adecuado, ahí tenemos tres paquetes. El servidor de nombres recursivo envía un paquete al servidor de TLD y recibe una respuesta que contiene el servidor autoritativo correcto. Ahora estamos en cinco paquetes. A continuación, el servidor de nombres recursivo envía su solicitud final al servidor de nombres autoritativo que envía una respuesta que contiene la IP para food.com. Eso son siete paquetes. Por último, el servidor de nombres local responde al agente de resolución de DNS que realizó la solicitud en primer lugar con la IP de food.com. Eso nos lleva a un total final de ocho paquetes. Mira, mucho menos paquetes.

Ahora puedes ver cuánta sobrecarga requiere TCP realmente. Y para algo tan simple como DNS, no es necesario. Es el ejemplo perfecto de por qué existen protocolos como UDP además de TCP, que es mucho más sólido.

Quizás te preguntes cómo entra en juego la recuperación de errores aquí, ya que UDP no tiene esa función. La respuesta es bastante simple. El agente de resolución de DNS vuelve a preguntar si no recibe una respuesta. Básicamente, la misma funcionalidad que TCP proporciona en la capa de transporte es proporcionada por DNS en la capa de aplicación de la manera más simple. Un servidor DNS nunca debe preocuparse por otra cosa que responder a las búsquedas entrantes, y un agente de resolución de DNS solo debe realizar búsquedas y repetirlas si no tiene éxito. Un verdadero modelo de la simplicidad de DNS y UDP.

Debo señalar que, de hecho, DNS sobre TCP existe y también se usa en todas partes. Como la Web se ha vuelto más compleja, ya no todas las respuestas de búsqueda de DNS pueden caber en un solo datagrama UDP. En estas situaciones, un servidor de nombres DNS responderá con un paquete que explica que la respuesta es demasiado grande. El cliente DNS establecerá una conexión TCP para realizar la búsqueda.
